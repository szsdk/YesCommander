#!/usr/bin/env python
import time
_STARTUP_t0 = time.time()
import threading
import multiprocessing
import sys
import term
from getkey import getkey, keys
from getkey.platforms import PlatformUnix
import os
import pyperclip
from pathlib import Path
import yescommander as yc


_CONFIG_PATH = Path("~/.config/yescommander/").expanduser()
sys.path.insert(0, str(_CONFIG_PATH))


def init_config_folder():
    import os

    if not _CONFIG_PATH.exists():
        _CONFIG_PATH.mkdir(parents=True, exist_ok=True)
    config_file = _CONFIG_PATH / "yc_rc.py"

    if not config_file.exists():
        import pkg_resources
        init_cfg_path = pkg_resources.resource_filename("yescommander", "example/rc.py")
        print(f"==== initalize {str(config_file)} ====")
        with open(init_cfg_path, "r") as fp:
            print(fp.read())
        os.system(f"cp {init_cfg_path} {config_file}")
    exit()


try:
    import yc_rc
except ModuleNotFoundError:
    init_config_folder()


_COMMANDS = yc_rc.commander
lazy_commander = yc_rc.lazy_commander


def update(listbox, text):
    listbox.commands = _COMMANDS.match(text.split(" "))


def execute(choices):
    choices.commands[choices.getSelected()].result()
    os._exit(0)


def copy(choices):
    pyperclip.copy(choices.commands[choices.getSelected()].copy_clipboard())


def preview_to_text(pv):
    ans = []
    for k, v in pv.items():
        ans.append(yc.StyledStr(k, color=yc.theme.preview.title_color))
        ans.append(v)
    return ans

def draw():
    textbox.draw()
    term.saveCursor()
    listbox.draw()
    if selection := choices.getSelection():
        labelbox.setText(preview_to_text(selection.preview()))
    else:
        labelbox.setText([])
    labelbox.draw()
    term.restoreCursor()


class PlatformYC(PlatformUnix):
    def getkey(self, blocking=True):
        buffer = ''
        for c in self.getchars(blocking):
            buffer += c
            time.sleep(0.001)

        keycode = self.keys.canon(buffer)
        if keycode in self.interrupts:
            interrupt = self.interrupts[keycode]
            if isinstance(interrupt, BaseException) or \
                issubclass(interrupt, BaseException):
                raise interrupt
            else:
                raise NotImplementedError('Unimplemented interrupt: {!r}'
                                          .format(interrupt))
        return keycode

platform = PlatformYC()

class StoppableThread(threading.Thread):
    """Thread class with a stop() method. The thread itself has to check
    regularly for the stopped() condition."""

    def __init__(self,  *args, **kwargs):
        super(StoppableThread, self).__init__(*args, **kwargs)
        self._stop_event = threading.Event()

    def stop(self):
        self._stop_event.set()

    def stopped(self):
        return self._stop_event.is_set()

    def run(self):
        keywords = textbox.text.split(" ")
        choices.commands = _COMMANDS.match(keywords)
        draw()
        queue = multiprocessing.Queue()
        proc = multiprocessing.Process(target=lazy_commander.match, args=(keywords, queue))
        proc.start()
        while proc.is_alive() and not self.stopped():
            try:
                n = queue.get(False)
                choices.commands.append(n)
                draw()
            except:
                pass
        proc.terminate()


def main_loop():
    draw()
    draw_thread = StoppableThread()
    ff = 0
    while True:
        key = platform.getkey()
        # TODO: Add more shortcuts
        # TODO: Chinese input
        ff += 1
        if key == keys.ENTER:
            win.clear()
            execute(choices)
        if key in ["\t", keys.DOWN, b"\x0e".decode()]:
            choices.selectNext()
            draw()
            continue
        if key in ["\x1b[Z", keys.UP, b"\x10".decode()]:
            choices.selectPrevious()
            draw()
            continue
        elif key == "\x04": # Ctrl + d
            copy(choices)
        else:
            textbox.key(key)
            choices._selected = 0
            draw_thread.stop()
            if draw_thread.is_alive():
                draw_thread.join()
            draw_thread = StoppableThread()
            draw_thread.start()


multiprocessing.set_start_method('fork')
sizey, sizex = term.getSize()
if sizey < 20 and sizex < 40:
    print("Current window is too small")
    exit()

if sizex > 80:
    height = 15
    label_height = height - 1
    win = yc.Window(height, sizex)

    textbox = yc.SearchBox(win, win.origin)
    choices = yc.ListBoxData()
    listbox = yc.ListBox(choices, win, (win.origin[0] + 1,  win.origin[1]), win.height - 1, width=int(win.width * yc.theme.listbox.ratio))
    labelbox = yc.Preview(
        win, (win.origin[0] + 1, win.origin[1] + listbox.width), (win.width - listbox.width), label_height
    )
else:
    height = 20 
    label_height = 8
    win = yc.Window(height, sizex)

    labelbox = yc.Preview(
        win, (win.origin[0], win.origin[1]), win.width, label_height 
    )
    textbox = yc.SearchBox(win, (win.origin[0] + labelbox.height, win.origin[1]))
    choices = yc.ListBoxData()
    listbox = yc.ListBox(choices, win, (win.origin[0] + 1 + labelbox.height, win.origin[1]), height - 1 - label_height, width=win.width)


debug_cmd = yc.DebugCommand()
debug_cmd.info["gui origins" ] = {"textbox position": textbox.origin,
"preview position": labelbox.origin,
"list position": listbox.origin}
_COMMANDS.append(debug_cmd)

debug_cmd.info["startup time (s)"] = time.time() - _STARTUP_t0
try:
    main_loop()
except KeyboardInterrupt:
    os._exit(0)
