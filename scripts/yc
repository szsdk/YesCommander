#!/usr/bin/env python

import time

_STARTUP_t0 = time.time()
from prompt_toolkit import Application
from prompt_toolkit.buffer import Buffer
from prompt_toolkit.layout.containers import VSplit, HSplit, Window
from prompt_toolkit.widgets import Frame
from prompt_toolkit.layout.controls import BufferControl, FormattedTextControl
from prompt_toolkit.formatted_text import FormattedText
from prompt_toolkit.layout.layout import Layout
from prompt_toolkit.key_binding import KeyBindings
from prompt_toolkit.output import ColorDepth

import shutil
from queue import Empty
import threading
import multiprocessing
import sys
import os
import pyperclip
from pathlib import Path
import yescommander as yc

multiprocessing.set_start_method("fork")

_CONFIG_PATH = Path("~/.config/yescommander/").expanduser()
sys.path.insert(0, str(_CONFIG_PATH))


def init_config_folder():
    import os

    if not _CONFIG_PATH.exists():
        _CONFIG_PATH.mkdir(parents=True, exist_ok=True)
    config_file = _CONFIG_PATH / "yc_rc.py"

    if not config_file.exists():
        import pkg_resources

        init_cfg_path = pkg_resources.resource_filename("yescommander", "example/rc.py")
        print(f"==== initalize {str(config_file)} ====")
        with open(init_cfg_path, "r") as fp:
            print(fp.read())
        os.system(f"cp {init_cfg_path} {config_file}")
    exit()


try:
    import yc_rc
except ModuleNotFoundError:
    init_config_folder()


commander = yc_rc.commander
lazy_commander = yc_rc.lazy_commander


class Preview(Window):
    def __init__(self, width, height=None, **kargs):
        super().__init__(
            content=FormattedTextControl(), width=width, height=height, **kargs
        )

    def update(self, cmd):
        ans = []
        for k, v in cmd.preview().items():
            ans.extend(
                [(yc.theme.preview.title_color, k), ("", "\n"), ("", v), ("", "\n")]
            )
        self.content.text = FormattedText(ans)


class ListBoxData:
    def __init__(self):
        self.commands = []
        self._selected = 0

    def isSelected(self, i):
        if self._selected is None:
            return False
        return self._selected == i

    def selectNext(self):
        self._selected = (self._selected + 1) % len(self)

    def selectPrevious(self):
        self._selected = (self._selected - 1) % len(self)

    def getSelected(self):
        self._selected = min(self._selected, len(self.commands) - 1)
        return self._selected

    def __len__(self):
        return len(self.commands)

    def __getitem__(self, idx):
        return self.commands[idx]

    def getSelection(self):
        if len(self.commands) == 0:
            return None
        return self.commands[self.getSelected()]


class ListBox(Window):
    def __init__(self, width, height=None, data=None):
        super().__init__(content=FormattedTextControl(), width=width, height=height)
        self._selected = 0
        if data is None:
            self.data = ListBoxData()
        else:
            self.data = data

    def get_start_end(self):
        selectedIndex = self.data.getSelected()
        halfHeight = self.height // 2
        if selectedIndex < halfHeight:
            start, end = 0, min(self.height, len(self.data))
        elif selectedIndex + halfHeight >= len(self.data):
            start, end = max(0, len(self.data) - self.height), len(self.data)
        else:
            start = max(0, selectedIndex - halfHeight)
            end = min(start + self.height, len(self.data))
        return start, end

    def update(self):
        t = []
        selected_idx = self.data.getSelected()
        for i in range(*self.get_start_end()):
            cmd = self.data[i]
            t.extend(
                [
                    (
                        yc.theme.marker_color,
                        cmd.marker
                        if hasattr(cmd, "marker")
                        else yc.theme.default_marker,
                    ),
                    (
                        f"{yc.theme.highlight_color} bold" if selected_idx == i else "",
                        cmd.str_command(),
                    ),
                    ("", "\n"),
                ]
            )
        self.content.text = FormattedText(t)


kb = KeyBindings()


@kb.add("c-c")
def exit_(event):
    """
    Pressing Ctrl-Q will exit the user interface.

    Setting a return value means: quit the event loop that drives the user
    interface and return this value from the `Application.run()` call.
    """
    event.app.stop_draw()
    event.app.exit()


@kb.add("c-p")
@kb.add("up")
def select_previous_(event):
    app = event.app
    app.listdata.selectPrevious()
    app.update()
    app.invalidate()


@kb.add("c-n")
@kb.add("down")
def select_next_(event):
    app = event.app
    app.listdata.selectNext()
    app.update()
    app.invalidate()


exit_cmd = lambda: None


@kb.add("enter")
def execute(event):
    app = event.app
    app.stop_draw()
    app.exit()
    global exit_cmd
    exit_cmd = app.listbox.data.getSelection().result


@kb.add("c-d")
def copy(event):
    app = event.app
    app.stop_draw()
    app.exit()

    def copy_cmd():
        pyperclip.copy(app.listbox.data.getSelection().copy_clipboard())
        print("Copied")

    global exit_cmd
    exit_cmd = copy_cmd


class StoppableThread(threading.Thread):
    """Thread class with a stop() method. The thread itself has to check
    regularly for the stopped() condition."""

    def __init__(self, app, *args, **kwargs):
        super(StoppableThread, self).__init__(*args, **kwargs)
        self._stop_event = threading.Event()
        self._app = app

    def stop(self):
        self._stop_event.set()

    def stopped(self):
        return self._stop_event.is_set()

    def run(self):
        searching_text = self._app.textbox_buffer.text
        keywords = searching_text.split(" ")
        if len(keywords) == 0:
            commands = []
        else:
            commands = commander.match(keywords)

        self._app.update(commands)

        queue = multiprocessing.Queue()
        proc = multiprocessing.Process(
            target=lazy_commander.match, args=(keywords, queue)
        )
        proc.start()
        while not self.stopped():
            try:
                n = queue.get(False)
                commands.append(n)
                self._app.update(commands)
            except Empty as e:
                if not proc.is_alive():
                    time.sleep(0.01)
                pass
        proc.terminate()


class YCApplication(Application):
    def __init__(self, width, height, **kargs):
        self.textbox_buffer = Buffer(
            on_text_changed=self.searching_text_changed, multiline=False
        )  # Editable buffer.
        self.textbox = Window(
            content=BufferControl(buffer=self.textbox_buffer),
            height=1,
            get_line_prefix=lambda line_num, wrap_count: FormattedText(
                [(yc.theme.highlight_color, yc.theme.prompt)]
            ),
        )
        self.listdata = ListBoxData()
        root_container = self._init_ui(width, height)
        super().__init__(
            layout=Layout(root_container),
            full_screen=False,
            key_bindings=kb,
            erase_when_done=True,
            **kargs,
        )

        self._draw_thread = StoppableThread(self)

    def _init_show_preview(self):
        if not yc.theme.preview.frame:
            return self.preview
        self.preview.width -= 2
        self.preview.height -= 2
        return Frame(
            self.preview,
            style=f"bg:{yc.theme.preview.bg_color} fg:{yc.theme.preview.frame_color}",
        )

    def _init_narrow(self, width, height):
        if height < yc.theme.narrow_height:
            raise RuntimeError(f"This terminal is too short {height} < {yc.theme.narrow_height}")

        self.preview = Preview(
            width=width,
            height=yc.theme.preview.narrow_height,
            style=f"bg:{yc.theme.preview.bg_color}",
        )
        self.listbox = ListBox(
            width=width, height=yc.theme.narrow_height - self.preview.height, data=self.listdata
        )
        root_container = HSplit([self._init_show_preview(), self.textbox, self.listbox])
        return root_container

    def _init_wide(self, width, height):
        if height < yc.theme.wide_height:
            raise RuntimeError(f"This terminal is too short {height} < {yc.theme.wide_height}")
        self.preview = Preview(
            width=int(0.6 * width),
            height=yc.theme.wide_height,
            style=f"bg:{yc.theme.preview.bg_color}",
        )
        self.listbox = ListBox(
            width=width - self.preview.width,
            height=yc.theme.wide_height - 1,
            data=self.listdata,
        )

        root_container = HSplit(
            [
                self.textbox,
                VSplit([self.listbox, self._init_show_preview()]),
            ]
        )
        return root_container

    def _init_ui(self, width, height):
        if width < yc.theme.max_narrow_width:
            return self._init_narrow(width, height)
        else:
            return self._init_wide(width, height)

    def searching_text_changed(self, buf):
        self._draw_thread.stop()
        if self._draw_thread.is_alive():
            self._draw_thread.join()
        self._draw_thread = StoppableThread(self)
        self._draw_thread.start()

    def update(self, commands=None):
        if commands is not None:
            self.listdata.commands = commands
        self.listbox.update()
        self.preview.update(self.listdata.getSelection())
        self.invalidate()

    def stop_draw(self):
        self._draw_thread.stop()


def main():
    terminal_size = shutil.get_terminal_size((80, 20))
    app = YCApplication(terminal_size.columns, terminal_size.lines, color_depth=ColorDepth.DEPTH_24_BIT)
    debug_cmd = yc.DebugCommand()
    commander.append(debug_cmd)
    debug_cmd.info["startup time (s)"] = time.time() - _STARTUP_t0
    debug_cmd.info["color depth"] = app.color_depth
    app.run()
    exit_cmd()


if __name__ == "__main__":
    main()
