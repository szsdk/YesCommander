#!/usr/bin/env python

"""
This is the terminal interface of YesCommander.
"""

from __future__ import annotations

import time

_STARTUP_t0 = time.time()


from prompt_toolkit import Application
from prompt_toolkit.buffer import Buffer
from prompt_toolkit.formatted_text import FormattedText
from prompt_toolkit.key_binding import KeyBindings, KeyPressEvent
from prompt_toolkit.layout.containers import (
    AnyContainer,
    Container,
    HSplit,
    VSplit,
    Window,
)
from prompt_toolkit.layout.controls import BufferControl, FormattedTextControl
from prompt_toolkit.layout.layout import Layout
from prompt_toolkit.output import ColorDepth
from prompt_toolkit.widgets import Frame

load_prompt_toolkit_t = time.time() - _STARTUP_t0

import multiprocessing
import os
import shutil
import sys
import threading
from functools import partial
from pathlib import Path
from pprint import pprint
from queue import Empty, Queue
from typing import (
    Any,
    Callable,
    Dict,
    Iterable,
    List,
    Optional,
    Tuple,
    cast,
    no_type_check,
)

import yescommander as yc

multiprocessing.set_start_method("fork")

_CONFIG_PATH = Path("~/.config/yescommander/").expanduser()
sys.path.insert(0, str(_CONFIG_PATH))


def init_config_folder() -> None:
    if not _CONFIG_PATH.exists():
        _CONFIG_PATH.mkdir(parents=True, exist_ok=True)
    config_file = _CONFIG_PATH / "yc_rc.py"

    if not config_file.exists():
        import pkg_resources

        init_cfg_path = pkg_resources.resource_filename(
            "yescommander", "example/yc_rc.py"
        )
        print(f"==== initalize {str(config_file)} ====")
        with open(init_cfg_path, "r") as fp:
            print(fp.read())
        os.system(f"cp {init_cfg_path} {config_file}")
    exit()


load_rc_t0 = time.time()
try:
    import yc_rc
except ModuleNotFoundError:
    init_config_folder()
load_rc_t = time.time() - load_rc_t0


class Preview(Window):
    def __init__(
        self,
        width: int,
        height: Optional[int] = None,
        debug_mode: bool = False,
        **kargs: Any,
    ) -> None:
        super().__init__(
            content=FormattedTextControl(),
            width=width,
            height=height,
            wrap_lines=True,
            **kargs,
        )
        self.debug_mode = debug_mode

    def update(self, cmd: yc.BaseCommand) -> None:
        ans = []
        for k, v in cmd.preview().items():
            ans.extend(
                [(yc.theme.preview.title_color, k), ("", "\n"), ("", v), ("", "\n")]
            )
        if self.debug_mode:
            ans.extend(
                [
                    (yc.theme.preview.title_color, "score (debug)"),
                    ("", "\n"),
                    ("", str(cmd.score)),
                    ("", "\n"),
                ]
            )
        cast(FormattedTextControl, self.content).text = FormattedText(ans)


class ListBoxData:
    def __init__(self) -> None:
        self.commands: List[yc.BaseCommand] = []
        self._selected: int = 0

    def isSelected(self, i: int) -> bool:
        if self._selected is None:
            return False
        return self._selected == i

    def selectNext(self, num=1) -> None:
        self._selected = 0 if len(self) == 0 else (self._selected + num) % len(self)

    def selectPrevious(self, num=1) -> None:
        self.selectNext(-num)

    def getSelected(self) -> int:
        if self._selected == -1 and len(self.commands) > 0:
            self._selected = 0
        else:
            self._selected = min(self._selected, len(self.commands) - 1)
        return self._selected

    def __len__(self) -> int:
        return len(self.commands)

    def __getitem__(self, idx: int) -> yc.BaseCommand:
        return self.commands[idx]

    def getSelection(self) -> Optional[yc.BaseCommand]:
        if len(self.commands) == 0:
            return None
        return self.commands[self.getSelected()]

    def sorted(self) -> None:
        self.commands = sorted(self.commands, key=lambda x: x.score, reverse=True)


class ListBox(Window):
    def __init__(
        self, width: int, height: int, data: Optional[ListBoxData] = None, **kargs: Any
    ) -> None:
        super().__init__(
            content=FormattedTextControl(), width=width, height=height, **kargs
        )
        self._selected = 0
        if data is None:
            self.data = ListBoxData()
        else:
            self.data = data

    def get_start_end(self) -> Tuple[int, int]:
        selectedIndex = self.data.getSelected()
        height = cast(int, self.height)
        halfHeight = height // 2
        if selectedIndex < halfHeight:
            start, end = 0, min(height, len(self.data))
        elif selectedIndex + halfHeight >= len(self.data):
            start, end = max(0, len(self.data) - height), len(self.data)
        else:
            start = max(0, selectedIndex - halfHeight)
            end = min(start + height, len(self.data))
        return start, end

    def update(self) -> None:
        t = []
        self.data.sorted()
        selected_idx = self.data.getSelected()
        for i in range(*self.get_start_end()):
            cmd = self.data[i]
            t.append(
                (
                    yc.theme.marker_color,
                    cmd.marker if hasattr(cmd, "marker") else yc.theme.default_marker,  # type: ignore
                )
            )
            try:
                s = str(cmd).splitlines()[0]
            except NotImplementedError:
                s = cmd.formatted_str()  # type: ignore
                # This is an undocumented method.
            if isinstance(s, FormattedText):
                t.extend(s)
            else:
                t.append(
                    (
                        f"{yc.theme.highlight_color} bold underline"
                        if selected_idx == i
                        else "",
                        s,
                    )
                )
            t.append(("", "\n"))
        self.content.text = FormattedText(t)  # type: ignore


exit_cmd: Callable[[], None] = lambda: None


class StoppableThread(threading.Thread):
    """Thread class with a stop() method. The thread itself has to check
    regularly for the stopped() condition."""

    def __init__(self, app: "YCApplication", *args: Any, **kwargs: Any) -> None:
        super(StoppableThread, self).__init__(*args, **kwargs)
        self._stop_event = threading.Event()
        self._app = app

    def stop(self) -> None:
        self._stop_event.set()

    def stopped(self) -> bool:
        return self._stop_event.is_set()

    def run(self) -> None:

        searching_text = self._app.textbox_buffer.text
        keywords = searching_text.strip().split(" ")
        if len(searching_text.strip()) == 0:
            self._app.update([])
            return

        queue: "multiprocessing.Queue[yc.BaseCommand]" = multiprocessing.Queue()
        proc = multiprocessing.Process(
            target=yc_rc.chief_commander.order, args=(keywords, queue)
        )
        proc.start()
        cmds = []
        while not self.stopped():
            updated = False
            try:
                for i in range(30):
                    cmds.append(queue.get(False))
                    updated = True
            except Empty:
                if not proc.is_alive():
                    time.sleep(0.1)
                pass
            if updated:
                self._app.update(cmds)
        proc.terminate()


class YCApplication(Application[None]):
    def __init__(self, width: int, height: int, **kargs: Any) -> None:
        self.textbox_buffer = Buffer(
            on_text_changed=self.searching_text_changed, multiline=False
        )  # Editable buffer.
        self.textbox = Window(
            content=BufferControl(buffer=self.textbox_buffer),
            height=1,
            get_line_prefix=self.get_line_prefix,
        )
        self.debug_mode = "--debug" in sys.argv
        self.listdata = ListBoxData()
        self._max_num = 2
        root_container = self._init_ui(width, height)
        super().__init__(
            layout=Layout(root_container),
            full_screen=False,
            key_bindings=kb,
            erase_when_done=True,
            **kargs,
        )

        self._draw_thread = StoppableThread(self)

    def get_line_prefix(self, line_num, wrap_count):
        idx = str(self.listdata.getSelected() + 1)
        num_cmds = str(len(self.listdata))
        self._max_num = max(self._max_num, len(idx), len(num_cmds))
        prompt = f"{idx.rjust(self._max_num)}/{num_cmds.ljust(self._max_num)} {yc.theme.searchbox.prompt}"
        return FormattedText([(yc.theme.highlight_color, prompt)])

    def _init_show_preview(self) -> AnyContainer:
        if not yc.theme.preview.frame:
            return self.preview
        self.preview.width = cast(int, self.preview.width) - 2
        self.preview.height = cast(int, self.preview.height) - 2
        return Frame(
            self.preview,
            style=f"bg:{yc.theme.preview.bg_color} fg:{yc.theme.preview.frame_color}",
        )

    def _init_narrow(self, width: int, height: int) -> Container:
        if height < yc.theme.narrow_height:
            raise RuntimeError(
                f"This terminal is too short {height} < {yc.theme.narrow_height}"
            )

        self.preview = Preview(
            width=width,
            height=yc.theme.preview.narrow_height,
            style=f"bg:{yc.theme.preview.bg_color}",
            debug_mode=self.debug_mode,
        )
        self.listbox = ListBox(
            width=width,
            height=yc.theme.narrow_height - self.preview.height,
            data=self.listdata,
            style=f"bg:{yc.theme.listbox.bg_color}",
        )
        root_container = HSplit([self._init_show_preview(), self.textbox, self.listbox])
        self.layout_mode = "narrow"
        return root_container

    def _init_wide(self, width: int, height: int) -> Container:
        if height < yc.theme.wide_height:
            raise RuntimeError(
                f"This terminal is too short {height} < {yc.theme.wide_height}"
            )
        self.preview = Preview(
            width=int(0.6 * width),
            height=yc.theme.wide_height,
            style=f"bg:{yc.theme.preview.bg_color}",
            debug_mode=self.debug_mode,
        )
        self.listbox = ListBox(
            width=width - cast(int, self.preview.width),
            height=yc.theme.wide_height - 1,
            data=self.listdata,
            style=f"bg:{yc.theme.listbox.bg_color}",
        )

        root_container = HSplit(
            [
                self.textbox,
                VSplit([self.listbox, self._init_show_preview()]),
            ]
        )
        self.layout_mode = "wide"
        return root_container

    def _init_ui(self, width: int, height: int) -> Container:
        if width < yc.theme.max_narrow_width:
            return self._init_narrow(width, height)
        else:
            return self._init_wide(width, height)

    def searching_text_changed(self, buf: Buffer) -> None:
        self._draw_thread.stop()
        if self._draw_thread.is_alive():
            self._draw_thread.join()
        self._draw_thread = StoppableThread(self)
        self._draw_thread.start()

    def update(self, commands: Optional[List[yc.BaseCommand]] = None) -> None:
        if commands is not None:
            self.listdata.commands = commands
        self.listbox.update()
        selection = self.listdata.getSelection()
        if selection is not None:
            self.preview.update(selection)
        self.invalidate()

    def stop_draw(self) -> None:
        self._draw_thread.stop()


_color_depth = {
    24: ColorDepth.DEPTH_24_BIT,
    8: ColorDepth.DEPTH_8_BIT,
    4: ColorDepth.DEPTH_4_BIT,
    1: ColorDepth.DEPTH_1_BIT,
}


class DebugSoldier(yc.BaseCommand, yc.BaseCommander):
    def __init__(self) -> None:
        self.info: Dict[str, Any] = {"theme": yc.theme.to_dict()}
        self.score = -1000

    def order(self, keywords: List[str], queue) -> None:
        if len(keywords) == 1 and keywords[0] == "debug":
            queue.put(self)

    def __str__(self) -> str:
        return "Debug"

    def preview(self) -> Dict[str, str]:
        return {"print debug infomation": ""}

    def result(self) -> None:
        pprint(self.info)


kb = KeyBindings()


def select_next_kernel(event: KeyPressEvent, n=1) -> None:
    app = cast(YCApplication, event.app)
    app.listdata.selectNext(n)
    app.update()
    app.invalidate()


@kb.add("enter")
def execute(event: KeyPressEvent) -> None:
    app = cast(YCApplication, event.app)
    app.stop_draw()
    app.exit()
    global exit_cmd
    selection = app.listbox.data.getSelection()
    if selection is not None:
        exit_cmd = selection.result


@kb.add("c-y")
def copy(event: KeyPressEvent) -> None:
    app = cast(YCApplication, event.app)
    app.stop_draw()
    app.exit()

    def copy_cmd() -> None:
        import pyperclip  # type: ignore

        selection = app.listbox.data.getSelection()
        if selection is not None:
            pyperclip.copy(selection.copy_clipboard())
            print("Copied")

    global exit_cmd
    exit_cmd = copy_cmd


@kb.add("c-c")
@kb.add("escape")
def exit_(event: KeyPressEvent) -> None:
    """
    Pressing Ctrl-Q will exit the user interface.

    Setting a return value means: quit the event loop that drives the user
    interface and return this value from the `Application.run()` call.
    """
    app = cast(YCApplication, event.app)
    app.stop_draw()
    app.exit()


def bind_keys(app):
    kb.add("c-d")(partial(select_next_kernel, n=app.listbox.height))
    kb.add("c-u")(partial(select_next_kernel, n=-app.listbox.height))
    kb.add("c-n")(partial(select_next_kernel, n=4))
    kb.add("c-p")(partial(select_next_kernel, n=-4))

    next_1 = partial(select_next_kernel, n=1)
    for keys in ["c-j", "down", "tab"]:
        kb.add(keys)(next_1)

    previous_1 = partial(select_next_kernel, n=-1)
    for keys in ["c-k", "up", "s-tab"]:
        kb.add(keys)(previous_1)


def main() -> None:
    terminal_size = shutil.get_terminal_size((80, 20))

    app = YCApplication(
        terminal_size.columns,
        terminal_size.lines,
        color_depth=_color_depth[yc.theme.color_depth],
    )
    app.ttimeoutlen = 0.01
    app.timeoutlen = 0.01
    bind_keys(app)

    debug_cmd = DebugSoldier()
    yc_rc.chief_commander.recruit(debug_cmd)
    debug_cmd.info.update(
        {
            "config file": str(_CONFIG_PATH / "yc_rc.py"),
            "loading time (s)": {
                "prompt_toolkit": load_prompt_toolkit_t,
                "rc": load_rc_t,
            },
            "terminal size": terminal_size,
            "file type viewer": yc.file_viewer,
            "layout mode": app.layout_mode,
        }
    )
    debug_cmd.info["loading time (s)"]["total"] = time.time() - _STARTUP_t0
    app.run()
    exit_cmd()


if __name__ == "__main__":

    main()
