#!/usr/bin/env python

import time

_STARTUP_t0 = time.time()
from prompt_toolkit import Application
from prompt_toolkit.buffer import Buffer
from prompt_toolkit.layout.containers import VSplit, HSplit, Window
from prompt_toolkit.widgets import Frame
from prompt_toolkit.layout.controls import BufferControl, FormattedTextControl
from prompt_toolkit.formatted_text import FormattedText
from prompt_toolkit.layout.layout import Layout
from prompt_toolkit.key_binding import KeyBindings

import shutil
from queue import Empty
import threading
import multiprocessing
import sys
import os
import pyperclip
from pathlib import Path
import yescommander as yc

multiprocessing.set_start_method("fork")

_CONFIG_PATH = Path("~/.config/yescommander/").expanduser()
sys.path.insert(0, str(_CONFIG_PATH))


def init_config_folder():
    import os

    if not _CONFIG_PATH.exists():
        _CONFIG_PATH.mkdir(parents=True, exist_ok=True)
    config_file = _CONFIG_PATH / "yc_rc.py"

    if not config_file.exists():
        import pkg_resources

        init_cfg_path = pkg_resources.resource_filename("yescommander", "example/rc.py")
        print(f"==== initalize {str(config_file)} ====")
        with open(init_cfg_path, "r") as fp:
            print(fp.read())
        os.system(f"cp {init_cfg_path} {config_file}")
    exit()


try:
    import yc_rc
except ModuleNotFoundError:
    init_config_folder()


commander = yc_rc.commander
lazy_commander = yc_rc.lazy_commander


class Preview(Window):
    def __init__(self, width, height=None):
        super().__init__(content=FormattedTextControl(), width=width, height=height)

    def update(self, cmd):
        ans = []
        for k, v in cmd.preview().items():
            ans.extend(
                [(yc.theme.preview.title_color, k), ("", "\n"), ("", v), ("", "\n")]
            )
        self.content.text = FormattedText(ans)


class ListBoxData:
    def __init__(self):
        self.commands = []
        self._selected = 0

    def isSelected(self, i):
        if self._selected is None:
            return False
        return self._selected == i

    def selectNext(self):
        self._selected = (self._selected + 1) % len(self)

    def selectPrevious(self):
        self._selected = (self._selected - 1) % len(self)

    def getSelected(self):
        self._selected = min(self._selected, len(self.commands) - 1)
        return self._selected

    def __len__(self):
        return len(self.commands)

    def __getitem__(self, idx):
        return self.commands[idx]

    def getSelection(self):
        if len(self.commands) == 0:
            return None
        return self.commands[self.getSelected()]


class ListBox(Window):
    def __init__(self, width, height=None, data=None):
        super().__init__(content=FormattedTextControl(), width=width, height=height)
        self._selected = 0
        if data is None:
            self.data = ListBoxData()
        else:
            self.data = data

    def get_start_end(self):
        selectedIndex = self.data.getSelected()
        halfHeight = self.height // 2
        if selectedIndex < halfHeight:
            start, end = 0, min(self.height, len(self.data))
        elif selectedIndex + halfHeight >= len(self.data):
            start, end = max(0, len(self.data) - self.height), len(self.data)
        else:
            start = max(0, selectedIndex - halfHeight)
            end = min(start + self.height, len(self.data))
        return start, end

    def update(self):
        t = []
        selected_idx = self.data.getSelected()
        for i in range(*self.get_start_end()):
            cmd = self.data[i]
            t.extend(
                [
                    (
                        yc.theme.marker_color,
                        cmd.marker
                        if hasattr(cmd, "marker")
                        else yc.theme.default_marker,
                    ),
                    (
                        f"{yc.theme.highlight_color} bold" if selected_idx == i else "",
                        cmd.str_command(),
                    ),
                    ("", "\n"),
                ]
            )
        self.content.text = FormattedText(t)


kb = KeyBindings()


@kb.add("c-c")
def exit_(event):
    """
    Pressing Ctrl-Q will exit the user interface.

    Setting a return value means: quit the event loop that drives the user
    interface and return this value from the `Application.run()` call.
    """
    event.app.stop_draw()
    event.app.exit()


@kb.add("c-p")
@kb.add("up")
def select_previous_(event):
    app = event.app
    app.listdata.selectPrevious()
    app.update()
    app.invalidate()


@kb.add("c-n")
@kb.add("down")
def select_next_(event):
    app = event.app
    app.listdata.selectNext()
    app.update()
    app.invalidate()


@kb.add("enter")
def execute(event):
    app = event.app
    app.stop_draw()
    app.exit()
    app.listbox.data.commands[app.listbox.data.getSelected()].result()


@kb.add("c-d")
def copy(event):
    app = event.app
    app.stop_draw()
    app.exit()
    pyperclip.copy(app.listbox.data.getSelection().copy_clipboard())
    print("Copied")


class StoppableThread(threading.Thread):
    """Thread class with a stop() method. The thread itself has to check
    regularly for the stopped() condition."""

    def __init__(self, app, *args, **kwargs):
        super(StoppableThread, self).__init__(*args, **kwargs)
        self._stop_event = threading.Event()
        self._app = app

    def stop(self):
        self._stop_event.set()

    def stopped(self):
        return self._stop_event.is_set()

    def run(self):
        searching_text = self._app.textbox_buffer.text
        keywords = searching_text.split(" ")
        if len(keywords) == 0:
            commands = []
        else:
            commands = commander.match(keywords)

        self._app.update(commands)

        queue = multiprocessing.Queue()
        proc = multiprocessing.Process(
            target=lazy_commander.match, args=(keywords, queue)
        )
        proc.start()
        while not self.stopped():
            try:
                n = queue.get(False)
                commands.append(n)
                self._app.update(commands)
            except Empty as e:
                if not proc.is_alive():
                    time.sleep(0.01)
                pass
        proc.terminate()


class YCApplication(Application):
    def __init__(self, width, height=16):
        prompt_marker = Window(
            width=2,
            height=1,
            content=FormattedTextControl(
                text=FormattedText([(yc.theme.highlight_color, yc.theme.prompt)])
            ),
        )
        self.textbox_buffer = Buffer(
            on_text_changed=self.searching_text_changed, multiline=False
        )  # Editable buffer.
        self.textbox = Window(
            content=BufferControl(buffer=self.textbox_buffer), height=1
        )
        self.listdata = ListBoxData()
        if width < 80:
            self.preview = Preview(width=width - 2, height=7)
            self.listbox = ListBox(
                width=width, height=height - self.preview.height, data=self.listdata
            )
            root_container = HSplit(
                [
                    Frame(self.preview, style=yc.theme.preview.frame_color)
                    if yc.theme.preview.frame
                    else self.preview,
                    VSplit([prompt_marker, self.textbox]),
                    self.listbox,
                ]
            )
        else:
            self.preview = Preview(width=int(0.6 * width) - 2, height=height - 3)
            self.listbox = ListBox(
                width=width - self.preview.width - 2,
                height=height - 1,
                data=self.listdata,
            )
            root_container = HSplit(
                [
                    VSplit([prompt_marker, self.textbox]),
                    VSplit(
                        [
                            self.listbox,
                            Frame(self.preview, style=yc.theme.preview.frame_color)
                            if yc.theme.preview.frame
                            else self.preview,
                        ]
                    ),
                ]
            )
        super().__init__(
            layout=Layout(root_container),
            full_screen=False,
            key_bindings=kb,
            erase_when_done=True,
        )

        self._draw_thread = StoppableThread(self)

    def searching_text_changed(self, buf):
        self._draw_thread.stop()
        if self._draw_thread.is_alive():
            self._draw_thread.join()
        self._draw_thread = StoppableThread(self)
        self._draw_thread.start()

    def update(self, commands=None):
        if commands is not None:
            self.listdata.commands = commands
        self.listbox.update()
        self.preview.update(self.listdata.getSelection())
        self.invalidate()

    def stop_draw(self):
        self._draw_thread.stop()


def main():
    terminal_size = shutil.get_terminal_size((80, 20))
    debug_cmd = yc.DebugCommand()
    commander.append(debug_cmd)
    debug_cmd.info["startup time (s)"] = time.time() - _STARTUP_t0
    app = YCApplication(terminal_size.columns, 19)
    app.run()


if __name__ == "__main__":
    main()
